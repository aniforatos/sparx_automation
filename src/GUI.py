# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'test.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets, uic
import threading
from sparx_automation import SparxAutomator, ConfigMgr
import logging
import time
import sys
import os
from src.sparx_auto_ui import Ui_MainWindow

sys._excepthook = sys.excepthook
bool_dict = {"True": True, "False": False}

# Handle high resolution displays:
if hasattr(QtCore.Qt, 'AA_EnableHighDpiScaling'):
    QtWidgets.QApplication.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling, True)
if hasattr(QtCore.Qt, 'AA_UseHighDpiPixmaps'):
    QtWidgets.QApplication.setAttribute(QtCore.Qt.AA_UseHighDpiPixmaps, True)
    
class GuiController(QtWidgets.QMainWindow):

    def __init__(self):
        QtWidgets.QMainWindow.__init__(self)
        self.ui = uic.loadUi("sparx_auto_ui.ui", self)
         
        
        # self.ui = Ui_MainWindow()
        # self.ui.setWindowIcon(QtGui.QIcon("./app_icon.ico"))
        # Handle when button clicked. Sends to scan function.
        self.extractCommentsBtn.clicked.connect(lambda: self.handle_start_button(self.extractCommentsBtn))
        self.stopBtn.clicked.connect(lambda: self.stop(self.stopBtn))
        self.updateDiagram.clicked.connect(lambda: self.populateDiagramField(self.updateDiagram))
        self.saveInfo.clicked.connect(lambda: self.setup_acct("save"))
        self.testJiraConnection.clicked.connect(lambda: self.setup_acct("verify"))        
        self.sendJira.clicked.connect(lambda: self.send_comments_to_jira(self.sendJira))
        self.actionSave_Results.triggered.connect(lambda: self.save_results())
        self.openHtml.stateChanged.connect(lambda:self.change_html_bool())
        self.thread = {}
        self.results_df = None
        self.isVerified = False  
        self.launchHtml = False      
        self.sparx = SparxAutomator()
        self.sparx.authenticate_jira()
        self.setup_acct("verify")

    def change_html_bool(self):
        if self.openHtml.isChecked():
            self.launchHtml = True
        else:
            self.launchHtml = False

    def pre_load_forms(self):
        '''Sets up buttons and entry fields with pre-loaded criteria that was saved
        from the previous session. This enables faster scanning. This function is only called
        after the GUI is launched.'''

        # Line edit objects
        self.criteria_dict = {"tcIssueId": None}
        jira_dict = {"acctEmail": None, "jiraApiKey": None}
        self.tableView.horizontalHeader().setStyleSheet("::section{Background-color:rgb(50,50,50);}")
        # self.progressBar.hide()

        # Populate entries with what was run from previous session.
        for key in list(self.criteria_dict.keys()):
            # if key == "tcRelVolume":
            #     self.centralwidget.findChild(QtWidgets.QComboBox, key).setCurrentText(ConfigMgr().pull_criteria(key))
            # else:            
            self.centralwidget.findChild(QtWidgets.QLineEdit, key).setText(ConfigMgr().pull_criteria(key, type="comment_extraction"))
            
            self.populateDiagramField(None)

        for key in list(jira_dict.keys()):
            self.centralwidget.findChild(QtWidgets.QLineEdit, key).setText(ConfigMgr().pull_criteria(key, type="jira"))

    def scan_bg_function(self, counter):
        cnt = counter
        index = self.sender().index
        if index == 1:
            self.progressBar.setValue(cnt)
        if index == 2:
            self.statusbar.showMessage("No. of Tickers that meet criteria: " + str(cnt))

    def setup_acct(self, field):
        _translate = QtCore.QCoreApplication.translate
        if field == "save":
            cfg_mgr = ConfigMgr()
            criteria_dict = {
                "acctEmail": self.centralwidget.findChild(QtWidgets.QLineEdit, "acctEmail").text(),
                "jiraApiKey": self.centralwidget.findChild(QtWidgets.QLineEdit, "jiraApiKey").text()
                }
            cfg_mgr.store_criteria(criteria_dict, type="jira")
            self.sparx.load_config()
            self.sparx.authenticate_jira()
            self.isVerified = self.sparx.check_jira_authentication()

        # TO be used to actually finish the verification process for the API, this was used as a test for encryption.
        elif field == "verify":
            self.isVerified = self.sparx.check_jira_authentication()
            if self.isVerified:
                self.statusbar.showMessage(f"JIRA Authenticated: {self.isVerified}")
            else:
                self.statusbar.showMessage(f"JIRA Authenticated: {self.isVerified}... Enter your information on the Setup tab.")


    def send_comments_to_jira(self, b):
        self.progressBar.setValue(0)
        if self.isVerified:
            self.results_df = self.sparx.write_dataframe_to_html_and_jira(self.results_df, self.criteria_dict["tcIssueId"])
            self.update_table()
        else:
            self.statusbar.showMessage("You are not Authenticated with JIRA!")
        
        self.progressBar.setValue(100)

    def save_results(self):

        if self.results_df is not None:
            self.results_df.to_csv("./data/" + self.criteria_dict["tcDiagramName"] + "_comments.csv")

        self.statusbar.showMessage("Results Saved!")

    def update_table(self):
        model = pandasModel(self.results_df)   
        self.tableView.setModel(model)
        self.tableView.setWordWrap(True)
        self.tableView.resizeColumnsToContents()
        self.tableView.setSizeAdjustPolicy(QtWidgets.QAbstractScrollArea.AdjustToContents)
                
        # Resize the first column (adjust the value based on your needs)
        self.tableView.setColumnWidth(3, 200)
        self.tableView.setColumnWidth(5, 200)

        # Set word wrap for the first column
        self.tableView.setWordWrap(True)

    def run_comment_extraction(self, criteria_dict):
        self.statusbar.showMessage("Beginning comment extractin...")
        self.progressBar.show()
        # self.thread[1] = ThreadClass(None, 1, self.sparx)
        # self.thread[1].start()

        self.results_df = self.sparx.extract_comments_from_diagram(criteria_dict, html=self.launchHtml)
        self.progressBar.setValue(100)
        self.statusbar.showMessage("Scan Complete!")
        ConfigMgr().store_criteria(criteria_dict, type="comment_extraction")        
        self.update_table()
        self.sendJira.setEnabled(True)           

    def populateDiagramField(self, btn):

        active_diagram = self.sparx.get_current_diagram_name(input=False)
        if active_diagram is not None:
            self.centralwidget.findChild(QtWidgets.QLineEdit, "tcDiagramId").setText(str(active_diagram.DiagramID))
            self.centralwidget.findChild(QtWidgets.QLineEdit, "tcDiagramName").setText(active_diagram.name)
            self.criteria_dict["tcDiagramId"] = active_diagram.DiagramID
            self.criteria_dict["tcDiagramName"] = active_diagram.name

    def run_scan(self, criteria_dict):
        '''Begin the scan through all tickers.'''
        self.statusbar.showMessage("Beginning comment extractin...")
        self.progressBar.show()

        self.thread[1] = ThreadClass(None, 1, self.SMGR)
        self.thread[1].start()
        self.thread[1].any_signal.connect(self.scan_bg_function)
        self.thread[2] = ThreadClass(None, 2, self.SMGR)
        self.thread[2].start()
        self.thread[2].any_signal.connect(self.scan_bg_function)

        self.results_df = self.SMGR.begin_scan(criteria_dict)
        self.thread[1].stop()
        self.thread[2].stop()
        self.progressBar.setValue(100)
        self.statusbar.showMessage("Scan Complete!")
        ConfigMgr().store_criteria(criteria_dict)
        model = pandasModel(self.results_df)
        self.tableView.setModel(model)

    def stop(self, b):
        try:
            self.thread[1].stop()
            self.thread[2].stop()
            self.SMGR.terminate_scan()
        except:
            pass

    def handle_start_button(self, b):
        '''Determine what button was pressed. If it is the start scan button then populate
        the criteria dictionary and call the scanning function.'''

        if b.objectName() == "extractCommentsBtn":
            for key in list(self.criteria_dict.keys()):
                self.criteria_dict[key] = self.centralwidget.findChild(QtWidgets.QLineEdit, key).text()

            self.run_comment_extraction(self.criteria_dict)


class ThreadClass(QtCore.QThread):
    any_signal = QtCore.pyqtSignal(int)

    def __init__(self, parent, index, mgrClass):
        super(ThreadClass, self).__init__(parent)
        self.index = index
        print(self.index)
        self.is_running = True
        self.mgrClass = mgrClass

    def run(self):
        while True:
            if self.index == 1:
                cnt = self.mgrClass.manage_status("progress")
                if cnt == 100: break
            else:
                cnt = self.mgrClass.manage_status("count")
            time.sleep(0.1)
            self.any_signal.emit(cnt)

    def stop(self):
        self.is_running = False
        print("Stop")
        if self.index == 1:
            self.any_signal.emit(100)
        self.terminate()

class pandasModel(QtCore.QAbstractTableModel):

    def __init__(self, data):
        QtCore.QAbstractTableModel.__init__(self)
        self._data = data

    def rowCount(self, parent=None):
        return self._data.shape[0]

    def columnCount(self, parnet=None):
        return self._data.shape[1]

    def data(self, index, role=QtCore.Qt.DisplayRole):
        if index.isValid():
            if role == QtCore.Qt.DisplayRole:
                return str(self._data.iloc[index.row(), index.column()])
        return None

    def headerData(self, col, orientation, role):
        if orientation == QtCore.Qt.Horizontal and role == QtCore.Qt.DisplayRole:
            return self._data.columns[col]
        return None


class progressThread(QtCore.QThread):
    progress_update = QtCore.pyqtSignal(int)  # or pyqtSignal(int)

    def __init__(self):
        QtCore.QThread.__init__(self)

    def __del__(self):
        self.wait()

    def run(self):
        # your logic here
        while 1:
            maxVal = 1  # NOTE THIS CHANGED to 1 since updateProgressBar was updating the value by 1 every time
            self.progress_update.emit(maxVal)  # self.emit(SIGNAL('PROGRESS'), maxVal)
            # Tell the thread to sleep for 1 second and let other things run
            time.sleep(1)
